<!DOCTYPE html><html lang="en" class="dark"> <head><!-- Global Metadata --><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><link rel="sitemap" href="/sitemap-index.xml"><link rel="alternate" type="application/rss+xml" title="Ayushman Malla" href="https://ayushmanmalla.github.io/rss.xml"><meta name="generator" content="Astro v5.14.1"><!-- Font preloads --><link rel="preload" href="/fonts/atkinson-regular.woff" as="font" type="font/woff" crossorigin><link rel="preload" href="/fonts/atkinson-bold.woff" as="font" type="font/woff" crossorigin><!-- Canonical URL --><link rel="canonical" href="https://ayushmanmalla.github.io/blog/branch-prediction/"><!-- Primary Meta Tags --><title>Branch Prediction: From CPU Hardware to Code Behavior</title><meta name="title" content="Branch Prediction: From CPU Hardware to Code Behavior"><meta name="description" content="Understanding how modern CPUs predict branches, and how to study branch prediction behavior using Python and C++."><!-- Open Graph / Facebook --><meta property="og:type" content="website"><meta property="og:url" content="https://ayushmanmalla.github.io/blog/branch-prediction/"><meta property="og:title" content="Branch Prediction: From CPU Hardware to Code Behavior"><meta property="og:description" content="Understanding how modern CPUs predict branches, and how to study branch prediction behavior using Python and C++."><meta property="og:image" content="https://ayushmanmalla.github.io/astro/blog-placeholder-1.Bx0Zcyzv.jpg"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://ayushmanmalla.github.io/blog/branch-prediction/"><meta property="twitter:title" content="Branch Prediction: From CPU Hardware to Code Behavior"><meta property="twitter:description" content="Understanding how modern CPUs predict branches, and how to study branch prediction behavior using Python and C++."><meta property="twitter:image" content="https://ayushmanmalla.github.io/astro/blog-placeholder-1.Bx0Zcyzv.jpg"><link rel="stylesheet" href="/astro/about.Ca1lyQ5E.css"></head> <body class="bg-background text-slate-200"> <header class="bg-background border-b-2 border-slate-800"> <nav class="mx-auto max-w-6xl px-4 sm:px-6 lg:px-8"> <div class="flex justify-between items-center py-4"> <h2 class="text-2xl font-bold text-slate-100"> <a href="/">Ayushman Malla</a> </h2> <div class="flex space-x-4"> <a href="/" class="text-slate-300 hover:text-accent"> Home </a> <a href="/blog" class="text-slate-300 hover:text-accent text-accent font-bold"> Blog </a> <a href="/about" class="text-slate-300 hover:text-accent"> About </a> </div> </div> </nav> </header> <main class="mx-auto max-w-3xl px-4 sm:px-6 lg:px-8"> <article> <div class="py-8"> <!-- {heroImage && <Image width={1020} height={510} src={heroImage} alt="" class="w-full h-auto rounded-lg shadow-md mb-8"/>} --> <img src="/astro/XWave.j83JwSMC_QCLAy.webp" alt loading="lazy" decoding="async" fetchpriority="auto" width="1020" height="510" class="w-full h-auto rounded-lg shadow-md mb-8"> </div> <div class="prose prose-lg prose-invert max-w-none"> <div class="text-center mb-8"> <p class="text-base text-slate-400"> <time datetime="2025-10-09T16:00:00.000Z"> Oct 10, 2025 </time>  </p> <h1 class="text-4xl font-bold tracking-tight text-slate-100 sm:text-5xl"> Branch Prediction: From CPU Hardware to Code Behavior </h1> <hr class="mt-6 border-slate-700"> </div>  <h2 id="introduction">Introduction</h2>
<p>Branch prediction lies at the heart of modern CPU performance. Every time your code executes a conditional statement — an <code>if</code>, <code>switch</code>, or loop — the CPU must decide which path to fetch next. A good prediction keeps the pipeline full. A bad one? It flushes the pipeline and wastes cycles.</p>
<p>This article walks through <strong>how branch prediction works at a hardware level</strong>, and compares <strong>how predictable control flow manifests differently in Python and C++</strong> when profiled.</p>
<hr>
<h2 id="1-the-basics-of-branch-prediction">1. The Basics of Branch Prediction</h2>
<p>Modern CPUs use a combination of:</p>
<ul>
<li><strong>Static prediction</strong> — predicting backward branches (loops) as taken and forward branches as not taken.</li>
<li><strong>Dynamic prediction</strong> — using historical data from <strong>Branch History Tables (BHTs)</strong> and <strong>Branch Target Buffers (BTBs)</strong>.</li>
<li><strong>Two-Level Adaptive Predictors</strong> — maintaining both global and local branch histories.</li>
</ul>
<p>Predictors learn from past outcomes, exploiting patterns in control flow. Speculative execution allows processors to continue fetching instructions down the predicted path until the actual condition is resolved.</p>
<hr>
<h2 id="2-why-it-matters-in-code">2. Why It Matters in Code</h2>
<p>Even high-level code is affected by branch predictability. For example:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="cpp"><code><span class="line"><span style="color:#6A737D">// C++ Example</span></span>
<span class="line"><span style="color:#F97583">int</span><span style="color:#B392F0"> count_positive</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">const</span><span style="color:#B392F0"> std</span><span style="color:#E1E4E8">::</span><span style="color:#B392F0">vector</span><span style="color:#E1E4E8">&#x3C;</span><span style="color:#F97583">int</span><span style="color:#E1E4E8">></span><span style="color:#F97583">&#x26;</span><span style="color:#FFAB70"> arr</span><span style="color:#E1E4E8">) {</span></span>
<span class="line"><span style="color:#F97583">    int</span><span style="color:#E1E4E8"> count </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">int</span><span style="color:#E1E4E8"> x : arr) {</span></span>
<span class="line"><span style="color:#F97583">        if</span><span style="color:#E1E4E8"> (x </span><span style="color:#F97583">></span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">) count</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">;</span><span style="color:#6A737D">  // predictable if data is biased</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> count;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<p>Predictable data (mostly positive or mostly negative) results in near-perfect prediction accuracy. Random data causes mispredictions and pipeline stalls.</p>
<p>In contrast, Python’s interpreter-based model abstracts away most hardware predictability effects, but microbenchmarks can still reveal differences in loop efficiency due to branch-heavy bytecode execution.</p>
<hr>
<h2 id="3-profiling-and-measuring-branch-behavior">3. Profiling and Measuring Branch Behavior</h2>
<h3 id="in-c">In C++</h3>
<p>Use <strong>perf</strong> or <strong>Intel VTune</strong>:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="bash"><code><span class="line"><span style="color:#B392F0">perf</span><span style="color:#9ECBFF"> stat</span><span style="color:#79B8FF"> -e</span><span style="color:#9ECBFF"> branch-instructions,branch-misses</span><span style="color:#9ECBFF"> ./a.out</span></span></code></pre>
<p>This gives direct visibility into how well your code aligns with the CPU’s branch predictor.</p>
<h3 id="in-python">In Python</h3>
<p>Branch prediction effects can be inferred through timing jitter or microbenchmarks:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="python"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> timeit</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8">setup </span><span style="color:#F97583">=</span><span style="color:#9ECBFF"> 'arr = [i % 2 for i in range(10_000_000)]'</span></span>
<span class="line"><span style="color:#E1E4E8">stmt </span><span style="color:#F97583">=</span><span style="color:#9ECBFF"> 'sum(1 for x in arr if x > 0)'</span></span>
<span class="line"><span style="color:#79B8FF">print</span><span style="color:#E1E4E8">(timeit.timeit(stmt, </span><span style="color:#FFAB70">setup</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">setup, </span><span style="color:#FFAB70">number</span><span style="color:#F97583">=</span><span style="color:#79B8FF">10</span><span style="color:#E1E4E8">))</span></span></code></pre>
<p>While Python doesn’t expose low-level counters, runtime differences still reflect cache and branching behavior of the interpreter loop.</p>
<hr>
<h2 id="4-comparing-c-and-python">4. Comparing C++ and Python</h2>

























<table><thead><tr><th>Aspect</th><th>C++</th><th>Python</th></tr></thead><tbody><tr><td>Execution Model</td><td>Compiled, CPU-level branching visible</td><td>Interpreted, VM-level branching abstracted</td></tr><tr><td>Profiling Tools</td><td><code>perf</code>, VTune, Valgrind</td><td><code>cProfile</code>, <code>timeit</code>, PyPerf</td></tr><tr><td>Branch Misprediction Sensitivity</td><td>High (directly impacts IPC)</td><td>Indirect (through interpreter overhead)</td></tr></tbody></table>
<p>C++ gives you visibility and control — you can even design your data structures to be branchless (using SIMD or lookup tables). Python abstracts away these details, making profiling more about algorithmic complexity than CPU microarchitecture.</p>
<hr>
<h2 id="5-closing-thoughts">5. Closing Thoughts</h2>
<p>Branch prediction is a quiet hero in modern computing — invisible until it fails. For performance-critical domains like trading, simulations, or embedded systems, understanding how control flow interacts with prediction hardware can yield massive speedups.</p>
<p>In future posts, we’ll explore <strong>branchless programming techniques</strong> and <strong>measuring speculative execution efficiency</strong> across architectures.</p>
<hr>
<p><em>Stay tuned for deeper dives into CPU behavior, compiler optimizations, and how they shape real-world system performance.</em></p>  </div> </article> </main> <footer class="text-center py-8"> <div class="text-slate-400">
&copy; 2025 Ayushman. All rights reserved.
</div> <div class="flex justify-center space-x-6 mt-4"> <a href="https://github.com/AyushmanMalla" target="_blank" rel="noopener noreferrer" class="text-slate-400 hover:text-accent">
GitHub
</a> <a href="https://www.linkedin.com/in/ayushman-malla-952900229/" target="_blank" rel="noopener noreferrer" class="text-slate-400 hover:text-accent">
LinkedIn
</a> <a href="mailto:ayushman.malla@e.ntu.edu.sg" class="text-slate-400 hover:text-accent">
Email
</a> </div> </footer> </body></html>