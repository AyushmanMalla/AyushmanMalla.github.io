<!DOCTYPE html><html lang="en" class="dark"> <head><!-- Global Metadata --><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" type="image/svg+xml" href="/favicon.svg"><link rel="sitemap" href="/sitemap-index.xml"><link rel="alternate" type="application/rss+xml" title="Ayushman Malla" href="https://ayushmanmalla.github.io/rss.xml"><meta name="generator" content="Astro v5.14.1"><!-- Font preloads --><link rel="preload" href="/fonts/atkinson-regular.woff" as="font" type="font/woff" crossorigin><link rel="preload" href="/fonts/atkinson-bold.woff" as="font" type="font/woff" crossorigin><!-- Canonical URL --><link rel="canonical" href="https://ayushmanmalla.github.io/blog/second-post/"><!-- Primary Meta Tags --><title>Cache Locality v/s Asymptotic Analysis</title><meta name="title" content="Cache Locality v/s Asymptotic Analysis"><meta name="description" content="Cache Locality v/s Asymptotic Analysis"><!-- Open Graph / Facebook --><meta property="og:type" content="website"><meta property="og:url" content="https://ayushmanmalla.github.io/blog/second-post/"><meta property="og:title" content="Cache Locality v/s Asymptotic Analysis"><meta property="og:description" content="Cache Locality v/s Asymptotic Analysis"><meta property="og:image" content="https://ayushmanmalla.github.io/astro/blog-placeholder-1.Bx0Zcyzv.jpg"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://ayushmanmalla.github.io/blog/second-post/"><meta property="twitter:title" content="Cache Locality v/s Asymptotic Analysis"><meta property="twitter:description" content="Cache Locality v/s Asymptotic Analysis"><meta property="twitter:image" content="https://ayushmanmalla.github.io/astro/blog-placeholder-1.Bx0Zcyzv.jpg"><link rel="stylesheet" href="/astro/about.Ca1lyQ5E.css"></head> <body class="bg-background text-slate-200"> <header class="bg-background border-b-2 border-slate-800"> <nav class="mx-auto max-w-6xl px-4 sm:px-6 lg:px-8"> <div class="flex justify-between items-center py-4"> <h2 class="text-2xl font-bold text-slate-100"> <a href="/">Ayushman Malla</a> </h2> <div class="flex space-x-4"> <a href="/" class="text-slate-300 hover:text-accent"> Home </a> <a href="/blog" class="text-slate-300 hover:text-accent text-accent font-bold"> Blog </a> <a href="/about" class="text-slate-300 hover:text-accent"> About </a> </div> </div> </nav> </header> <main class="mx-auto max-w-3xl px-4 sm:px-6 lg:px-8"> <article> <div class="py-8"> <!-- {heroImage && <Image width={1020} height={510} src={heroImage} alt="" class="w-full h-auto rounded-lg shadow-md mb-8"/>} --> <img src="/astro/wave.BRHL1xGo_Z1XG8St.webp" alt loading="lazy" decoding="async" fetchpriority="auto" width="1020" height="510" class="w-full h-auto rounded-lg shadow-md mb-8"> </div> <div class="prose prose-lg prose-invert max-w-none"> <div class="text-center mb-8"> <p class="text-base text-slate-400"> <time datetime="2025-11-17T16:00:00.000Z"> Nov 18, 2025 </time>  </p> <h1 class="text-4xl font-bold tracking-tight text-slate-100 sm:text-5xl"> Cache Locality v/s Asymptotic Analysis </h1> <hr class="mt-6 border-slate-700"> </div>  <p>As programmers, we’re often taught to analyze algorithms using Big O notation. An algorithm that is O(n) is better than one that is O(n²), and we strive to find the most efficient algorithm in terms of its asymptotic complexity. But what happens when two algorithms have the same complexity? Are they always equally fast?</p>
<p>The answer, perhaps surprisingly, is no. In this post, we’ll explore a fascinating example that demonstrates how the underlying hardware, specifically the CPU cache, can have a dramatic impact on performance. We’ll look at two O(n²) algorithms for traversing a 2D matrix and see why one is significantly faster than the other, thanks to a concept called <strong>cache locality</strong>.</p>
<h3 id="asymptotic-analysis-a-quick-refresher">Asymptotic Analysis: A Quick Refresher</h3>
<p>Asymptotic analysis, or Big O notation, is a way to describe the performance of an algorithm as the input size grows. It gives us a high-level understanding of how an algorithm scales. For example, an O(n²) algorithm’s runtime will grow quadratically with the input size <code>n</code>.</p>
<p>While incredibly useful, Big O notation deliberately ignores constants and lower-order terms. It doesn’t care about the exact number of operations, but rather the growth rate. This means that two O(n²) algorithms might have very different constant factors, leading to different real-world performance.</p>
<h3 id="the-memory-hierarchy-and-cache-locality">The Memory Hierarchy and Cache Locality</h3>
<p>Modern computers have a memory hierarchy. At the top, we have CPU registers, which are extremely fast but very small. Then we have multiple levels of cache (L1, L2, L3), which are progressively larger but slower. Finally, we have the main memory (RAM), which is much larger but also much slower than the cache.</p>
<p><img src="https://i.imgur.com/s3yZz6X.png" alt="Memory Hierarchy"></p>
<p>When the CPU needs to access data, it first checks the L1 cache. If the data is there (a <strong>cache hit</strong>), it’s accessed very quickly. If not (a <strong>cache miss</strong>), the CPU checks the L2 cache, then L3, and finally RAM. Each level of miss incurs a significant performance penalty.</p>
<p>To minimize cache misses, modern CPUs are designed to exploit two principles of locality:</p>
<ul>
<li><strong>Temporal Locality:</strong> If a piece of data is accessed, it’s likely to be accessed again soon.</li>
<li><strong>Spatial Locality:</strong> If a piece of data is accessed, it’s likely that data near it in memory will be accessed soon.</li>
</ul>
<p>When a cache miss occurs, the CPU doesn’t just fetch the single piece of data it needs from RAM. It fetches a whole block of contiguous data (called a cache line) and stores it in the cache, anticipating that nearby data will be needed soon. This is where our 2D matrix example comes in.</p>
<h3 id="the-2d-matrix-traversal-problem">The 2D Matrix Traversal Problem</h3>
<p>Let’s consider a simple task: summing all the elements in a large 2D matrix. We can do this in two ways:</p>
<ol>
<li><strong>Row-major traversal:</strong> Iterate through each row, and for each row, iterate through its columns.</li>
<li><strong>Column-major traversal:</strong> Iterate through each column, and for each column, iterate through its rows.</li>
</ol>
<p>Here’s how you might write this in Python using NumPy:</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="python"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> numpy </span><span style="color:#F97583">as</span><span style="color:#E1E4E8"> np</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D"># Create a large 10000x10000 matrix</span></span>
<span class="line"><span style="color:#E1E4E8">matrix </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> np.ones((</span><span style="color:#79B8FF">10000</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">10000</span><span style="color:#E1E4E8">))</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">def</span><span style="color:#B392F0"> sum_row_major</span><span style="color:#E1E4E8">(matrix):</span></span>
<span class="line"><span style="color:#E1E4E8">    total </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">in</span><span style="color:#79B8FF"> range</span><span style="color:#E1E4E8">(matrix.shape[</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">]):</span></span>
<span class="line"><span style="color:#F97583">        for</span><span style="color:#E1E4E8"> j </span><span style="color:#F97583">in</span><span style="color:#79B8FF"> range</span><span style="color:#E1E4E8">(matrix.shape[</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">]):</span></span>
<span class="line"><span style="color:#E1E4E8">            total </span><span style="color:#F97583">+=</span><span style="color:#E1E4E8"> matrix[i, j]</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> total</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">def</span><span style="color:#B392F0"> sum_column_major</span><span style="color:#E1E4E8">(matrix):</span></span>
<span class="line"><span style="color:#E1E4E8">    total </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> j </span><span style="color:#F97583">in</span><span style="color:#79B8FF"> range</span><span style="color:#E1E4E8">(matrix.shape[</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">]):</span></span>
<span class="line"><span style="color:#F97583">        for</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">in</span><span style="color:#79B8FF"> range</span><span style="color:#E1E4E8">(matrix.shape[</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">]):</span></span>
<span class="line"><span style="color:#E1E4E8">            total </span><span style="color:#F97583">+=</span><span style="color:#E1E4E8"> matrix[i, j]</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> total</span></span></code></pre>
<p>Both of these functions have two nested loops, each running <code>n</code> times (where <code>n</code> is the dimension of the matrix). Therefore, both have a time complexity of O(n²). Asymptotically, they are identical. But in practice, their performance is anything but.</p>
<h3 id="the-performance-difference-its-all-about-the-cache">The Performance Difference: It’s All About the Cache</h3>
<p>In languages like C, C++, and Python (with NumPy), 2D arrays are typically stored in memory in <strong>row-major order</strong>. This means that the elements of the first row are stored contiguously, followed by the elements of the second row, and so on.</p>
<p><img src="https://i.imgur.com/2X2bB8c.png" alt="Row-Major Order"></p>
<p><strong>Row-major traversal</strong> accesses the elements in the exact order they are laid out in memory: <code>matrix[0,0]</code>, <code>matrix[0,1]</code>, <code>matrix[0,2]</code>, … This is a perfect example of spatial locality. When the CPU fetches the first element, it also loads the next few elements into the cache line. Subsequent accesses are then lightning-fast cache hits.</p>
<p><strong>Column-major traversal</strong>, on the other hand, jumps around in memory. It accesses <code>matrix[0,0]</code>, then <code>matrix[1,0]</code>, then <code>matrix[2,0]</code>, etc. These elements are far apart in memory (separated by the length of a full row). Each access is likely to result in a cache miss, forcing the CPU to go all the way to RAM, which is orders of magnitude slower.</p>
<h3 id="lets-benchmark-it">Let’s Benchmark It</h3>
<p>We can use Python’s <code>timeit</code> module to see the difference.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="python"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> numpy </span><span style="color:#F97583">as</span><span style="color:#E1E4E8"> np</span></span>
<span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> timeit</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D"># Create a large 10000x10000 matrix</span></span>
<span class="line"><span style="color:#E1E4E8">matrix </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> np.ones((</span><span style="color:#79B8FF">10000</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">10000</span><span style="color:#E1E4E8">))</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">def</span><span style="color:#B392F0"> sum_row_major</span><span style="color:#E1E4E8">(matrix):</span></span>
<span class="line"><span style="color:#E1E4E8">    total </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">in</span><span style="color:#79B8FF"> range</span><span style="color:#E1E4E8">(matrix.shape[</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">]):</span></span>
<span class="line"><span style="color:#F97583">        for</span><span style="color:#E1E4E8"> j </span><span style="color:#F97583">in</span><span style="color:#79B8FF"> range</span><span style="color:#E1E4E8">(matrix.shape[</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">]):</span></span>
<span class="line"><span style="color:#E1E4E8">            total </span><span style="color:#F97583">+=</span><span style="color:#E1E4E8"> matrix[i, j]</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> total</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">def</span><span style="color:#B392F0"> sum_column_major</span><span style="color:#E1E4E8">(matrix):</span></span>
<span class="line"><span style="color:#E1E4E8">    total </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> j </span><span style="color:#F97583">in</span><span style="color:#79B8FF"> range</span><span style="color:#E1E4E8">(matrix.shape[</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">]):</span></span>
<span class="line"><span style="color:#F97583">        for</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">in</span><span style="color:#79B8FF"> range</span><span style="color:#E1E4E8">(matrix.shape[</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">]):</span></span>
<span class="line"><span style="color:#E1E4E8">            total </span><span style="color:#F97583">+=</span><span style="color:#E1E4E8"> matrix[i, j]</span></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#E1E4E8"> total</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D"># Benchmark</span></span>
<span class="line"><span style="color:#E1E4E8">row_time </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> timeit.timeit(</span><span style="color:#F97583">lambda</span><span style="color:#E1E4E8">: sum_row_major(matrix), </span><span style="color:#FFAB70">number</span><span style="color:#F97583">=</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#E1E4E8">col_time </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> timeit.timeit(</span><span style="color:#F97583">lambda</span><span style="color:#E1E4E8">: sum_column_major(matrix), </span><span style="color:#FFAB70">number</span><span style="color:#F97583">=</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">)</span></span>
<span class="line"></span>
<span class="line"><span style="color:#79B8FF">print</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">f</span><span style="color:#9ECBFF">"Row-major traversal time: </span><span style="color:#79B8FF">{</span><span style="color:#E1E4E8">row_time</span><span style="color:#F97583">:.4f</span><span style="color:#79B8FF">}</span><span style="color:#9ECBFF"> seconds"</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#79B8FF">print</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">f</span><span style="color:#9ECBFF">"Column-major traversal time: </span><span style="color:#79B8FF">{</span><span style="color:#E1E4E8">col_time</span><span style="color:#F97583">:.4f</span><span style="color:#79B8FF">}</span><span style="color:#9ECBFF"> seconds"</span><span style="color:#E1E4E8">)</span></span>
<span class="line"><span style="color:#79B8FF">print</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">f</span><span style="color:#9ECBFF">"Difference: Column-major is </span><span style="color:#79B8FF">{</span><span style="color:#E1E4E8">col_time </span><span style="color:#F97583">/</span><span style="color:#E1E4E8"> row_time</span><span style="color:#F97583">:.2f</span><span style="color:#79B8FF">}</span><span style="color:#9ECBFF">x slower"</span><span style="color:#E1E4E8">)</span></span></code></pre>
<p>When you run this, you’ll see a significant difference. The row-major traversal will be much faster. The exact numbers will depend on your machine, but it’s not uncommon to see the column-major traversal being 5-10x slower or even more!</p>
<h3 id="a-c-demonstration">A C++ Demonstration</h3>
<p>The effect is even more pronounced in a language like C++ where we have more direct control over memory.</p>
<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0" data-language="cpp"><code><span class="line"><span style="color:#F97583">#include</span><span style="color:#9ECBFF"> &#x3C;iostream></span></span>
<span class="line"><span style="color:#F97583">#include</span><span style="color:#9ECBFF"> &#x3C;vector></span></span>
<span class="line"><span style="color:#F97583">#include</span><span style="color:#9ECBFF"> &#x3C;chrono></span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">const</span><span style="color:#F97583"> int</span><span style="color:#E1E4E8"> SIZE </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 10000</span><span style="color:#E1E4E8">;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">int</span><span style="color:#B392F0"> main</span><span style="color:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#B392F0">    std</span><span style="color:#E1E4E8">::vector</span><span style="color:#F97583">&#x3C;</span><span style="color:#B392F0">std</span><span style="color:#E1E4E8">::vector</span><span style="color:#F97583">&#x3C;int>></span><span style="color:#B392F0"> matrix</span><span style="color:#E1E4E8">(SIZE, </span><span style="color:#B392F0">std</span><span style="color:#E1E4E8">::</span><span style="color:#B392F0">vector</span><span style="color:#E1E4E8">&#x3C;</span><span style="color:#F97583">int</span><span style="color:#E1E4E8">>(SIZE, </span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">));</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">    // Row-major traversal</span></span>
<span class="line"><span style="color:#F97583">    auto</span><span style="color:#E1E4E8"> start </span><span style="color:#F97583">=</span><span style="color:#B392F0"> std</span><span style="color:#E1E4E8">::</span><span style="color:#B392F0">chrono</span><span style="color:#E1E4E8">::</span><span style="color:#B392F0">high_resolution_clock</span><span style="color:#E1E4E8">::</span><span style="color:#B392F0">now</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">    long</span><span style="color:#F97583"> long</span><span style="color:#E1E4E8"> sum1 </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">int</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; i </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> SIZE; </span><span style="color:#F97583">++</span><span style="color:#E1E4E8">i) {</span></span>
<span class="line"><span style="color:#F97583">        for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">int</span><span style="color:#E1E4E8"> j </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; j </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> SIZE; </span><span style="color:#F97583">++</span><span style="color:#E1E4E8">j) {</span></span>
<span class="line"><span style="color:#E1E4E8">            sum1 </span><span style="color:#F97583">+=</span><span style="color:#E1E4E8"> matrix[i][j];</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#F97583">    auto</span><span style="color:#E1E4E8"> end </span><span style="color:#F97583">=</span><span style="color:#B392F0"> std</span><span style="color:#E1E4E8">::</span><span style="color:#B392F0">chrono</span><span style="color:#E1E4E8">::</span><span style="color:#B392F0">high_resolution_clock</span><span style="color:#E1E4E8">::</span><span style="color:#B392F0">now</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#B392F0">    std</span><span style="color:#E1E4E8">::</span><span style="color:#B392F0">chrono</span><span style="color:#E1E4E8">::duration</span><span style="color:#F97583">&#x3C;double></span><span style="color:#E1E4E8"> row_duration </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> end </span><span style="color:#F97583">-</span><span style="color:#E1E4E8"> start;</span></span>
<span class="line"><span style="color:#B392F0">    std</span><span style="color:#E1E4E8">::cout </span><span style="color:#F97583">&#x3C;&#x3C;</span><span style="color:#9ECBFF"> "Row-major traversal time: "</span><span style="color:#F97583"> &#x3C;&#x3C;</span><span style="color:#E1E4E8"> row_duration.</span><span style="color:#B392F0">count</span><span style="color:#E1E4E8">() </span><span style="color:#F97583">&#x3C;&#x3C;</span><span style="color:#9ECBFF"> " seconds"</span><span style="color:#F97583"> &#x3C;&#x3C;</span><span style="color:#B392F0"> std</span><span style="color:#E1E4E8">::endl;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6A737D">    // Column-major traversal</span></span>
<span class="line"><span style="color:#E1E4E8">    start </span><span style="color:#F97583">=</span><span style="color:#B392F0"> std</span><span style="color:#E1E4E8">::</span><span style="color:#B392F0">chrono</span><span style="color:#E1E4E8">::</span><span style="color:#B392F0">high_resolution_clock</span><span style="color:#E1E4E8">::</span><span style="color:#B392F0">now</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#F97583">    long</span><span style="color:#F97583"> long</span><span style="color:#E1E4E8"> sum2 </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#F97583">    for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">int</span><span style="color:#E1E4E8"> j </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; j </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> SIZE; </span><span style="color:#F97583">++</span><span style="color:#E1E4E8">j) {</span></span>
<span class="line"><span style="color:#F97583">        for</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">int</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; i </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> SIZE; </span><span style="color:#F97583">++</span><span style="color:#E1E4E8">i) {</span></span>
<span class="line"><span style="color:#E1E4E8">            sum2 </span><span style="color:#F97583">+=</span><span style="color:#E1E4E8"> matrix[i][j];</span></span>
<span class="line"><span style="color:#E1E4E8">        }</span></span>
<span class="line"><span style="color:#E1E4E8">    }</span></span>
<span class="line"><span style="color:#E1E4E8">    end </span><span style="color:#F97583">=</span><span style="color:#B392F0"> std</span><span style="color:#E1E4E8">::</span><span style="color:#B392F0">chrono</span><span style="color:#E1E4E8">::</span><span style="color:#B392F0">high_resolution_clock</span><span style="color:#E1E4E8">::</span><span style="color:#B392F0">now</span><span style="color:#E1E4E8">();</span></span>
<span class="line"><span style="color:#B392F0">    std</span><span style="color:#E1E4E8">::</span><span style="color:#B392F0">chrono</span><span style="color:#E1E4E8">::duration</span><span style="color:#F97583">&#x3C;double></span><span style="color:#E1E4E8"> col_duration </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> end </span><span style="color:#F97583">-</span><span style="color:#E1E4E8"> start;</span></span>
<span class="line"><span style="color:#B392F0">    std</span><span style="color:#E1E4E8">::cout </span><span style="color:#F97583">&#x3C;&#x3C;</span><span style="color:#9ECBFF"> "Column-major traversal time: "</span><span style="color:#F97583"> &#x3C;&#x3C;</span><span style="color:#E1E4E8"> col_duration.</span><span style="color:#B392F0">count</span><span style="color:#E1E4E8">() </span><span style="color:#F97583">&#x3C;&#x3C;</span><span style="color:#9ECBFF"> " seconds"</span><span style="color:#F97583"> &#x3C;&#x3C;</span><span style="color:#B392F0"> std</span><span style="color:#E1E4E8">::endl;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#B392F0">    std</span><span style="color:#E1E4E8">::cout </span><span style="color:#F97583">&#x3C;&#x3C;</span><span style="color:#9ECBFF"> "Difference: Column-major is "</span><span style="color:#F97583"> &#x3C;&#x3C;</span><span style="color:#E1E4E8"> col_duration.</span><span style="color:#B392F0">count</span><span style="color:#E1E4E8">() </span><span style="color:#F97583">/</span><span style="color:#E1E4E8"> row_duration.</span><span style="color:#B392F0">count</span><span style="color:#E1E4E8">() </span><span style="color:#F97583">&#x3C;&#x3C;</span><span style="color:#9ECBFF"> "x slower"</span><span style="color:#F97583"> &#x3C;&#x3C;</span><span style="color:#B392F0"> std</span><span style="color:#E1E4E8">::endl;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#F97583">    return</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>
<span class="line"><span style="color:#E1E4E8">}</span></span></code></pre>
<h3 id="conclusion">Conclusion</h3>
<p>Asymptotic analysis is a fundamental tool for algorithm design, but it’s not the whole story. Understanding how your code interacts with the underlying hardware can lead to significant performance improvements. The 2D matrix traversal example is a classic demonstration of how a simple change that respects cache locality can make an O(n²) algorithm dramatically faster than another O(n²) algorithm.</p>
<p>So next time you’re optimizing a piece of code, don’t just think about the Big O. Think about the memory access patterns too. You might be surprised at the performance gains you can achieve.</p>  </div> </article> </main> <footer class="text-center py-8"> <div class="text-slate-400">
&copy; 2025 Ayushman. All rights reserved.
</div> <div class="flex justify-center space-x-6 mt-4"> <a href="https://github.com/AyushmanMalla" target="_blank" rel="noopener noreferrer" class="text-slate-400 hover:text-accent">
GitHub
</a> <a href="https://www.linkedin.com/in/ayushman-malla-952900229/" target="_blank" rel="noopener noreferrer" class="text-slate-400 hover:text-accent">
LinkedIn
</a> <a href="mailto:ayushman.malla@e.ntu.edu.sg" class="text-slate-400 hover:text-accent">
Email
</a> </div> </footer> </body></html>